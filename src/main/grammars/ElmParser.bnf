{
    generate = [ psi = "no" ]
    psiClassPrefix="Elm"
    parserClass="org.elm.lang.core.parser.ElmParser"
    elementTypeHolderClass="org.elm.lang.core.psi.ElmTypes"
    parserUtilClass="org.elm.lang.core.parser.manual.ElmParserUtil"
    elementTypeClass="org.elm.lang.core.psi.ElmElementType"
    tokenTypeClass="org.elm.lang.core.psi.ElmTokenType"

    elementTypeFactory("module_declaration")="org.elm.lang.core.stubs.ElmStubImplementationsKt.factory"
    elementTypeFactory("type_declaration")="org.elm.lang.core.stubs.ElmStubImplementationsKt.factory"
    elementTypeFactory("type_alias_declaration")="org.elm.lang.core.stubs.ElmStubImplementationsKt.factory"
    elementTypeFactory("union_member")="org.elm.lang.core.stubs.ElmStubImplementationsKt.factory"

    tokens = [
        // tokens used by manual/external parse rules
        UPPER_CASE_QID='UPPER_CASE_QID'
        VALUE_QID='VALUE_QID'
        FIELD_ACCESS='FIELD_ACCESS'
        FIELD_ACCESSOR_FUNCTION='FIELD_ACCESSOR_FUNCTION'
        DOT='DOT'
        EFFECT='EFFECT'

        // tokens used by the lexer but not visible to PsiBuilder parser
        // TODO [kl] cleanup the mess of 'comment' tokens
        RESERVED='RESERVED'
        LINE_COMMENT='LINE_COMMENT'
        START_COMMENT='START_COMMENT'
        START_DOC_COMMENT='START_DOC_COMMENT'
        COMMENT_CONTENT='COMMENT_CONTENT'
        END_COMMENT='END_COMMENT'
        NEWLINE='NEWLINE'
        TAB='TAB'
    ]
}


elmFile ::= [module_declaration] body

module_declaration ::= [ effect | PORT ] MODULE upper_case_qid [ WHERE record ] exposing_list

private body ::= import_clauses top_declarations VIRTUAL_END_SECTION?

private import_clauses ::= <<decls import_clause>>

private top_declarations ::= <<decls declaration>>



// MODULE DECLARATION


exposing_list ::= EXPOSING LEFT_PARENTHESIS (DOUBLE_DOT | list_of_values) RIGHT_PARENTHESIS

private list_of_values ::= <<non_empty_list exposed_item>>

private exposed_item ::=
    exposed_value
    | operator_as_function
    | exposed_type

exposed_value ::= LOWER_CASE_IDENTIFIER

exposed_type ::=
    UPPER_CASE_IDENTIFIER [exposed_union_constructors]

exposed_union_constructors ::=
    LEFT_PARENTHESIS (DOUBLE_DOT | (<<non_empty_list exposed_union_constructor>>)) RIGHT_PARENTHESIS

exposed_union_constructor ::=
    UPPER_CASE_IDENTIFIER



// IMPORT DECLARATION


import_clause ::= IMPORT upper_case_qid [as_clause] [exposing_list]

as_clause ::= AS UPPER_CASE_IDENTIFIER



// TOP-LEVEL DECLARATIONS


private declaration ::=
    value_declaration
    | type_alias_declaration
    | type_declaration
    | type_annotation
    | port_annotation
    | operator_config
/* TODO [kl] re-enable after the big refactoring (see HaskForce BNF for ideas)
  (previously the recovery relied on FRESH_LINE, which no longer exists)
{
    pin = 1
    recoverWhile = declaration_recover
}
*/

value_declaration ::= internal_value_declaration_left EQ expression

private internal_value_declaration_left ::=
    function_declaration_left
    | operator_declaration_left
    | pattern

function_declaration_left ::=
    LOWER_CASE_IDENTIFIER pattern*

operator_declaration_left ::=
    operator_as_function pattern*



// TYPE DECLARATIONS AND REFERENCES


type_declaration ::=
    TYPE UPPER_CASE_IDENTIFIER (lower_type_name)* EQ union_member (PIPE union_member)*

lower_type_name ::= LOWER_CASE_IDENTIFIER

union_member ::=
    UPPER_CASE_IDENTIFIER single_type_ref*


type_alias_declaration ::=
    TYPE ALIAS UPPER_CASE_IDENTIFIER lower_type_name* EQ type_ref

type_ref ::=
    type_ref_inner (ARROW type_ref_inner)*

private type_ref_inner ::=
    parametric_type_ref
    | single_type_ref

parametric_type_ref ::= upper_case_qid (single_type_ref)+

private single_type_ref ::=
    upper_path_type_ref
    | type_variable_ref
    | record_type
    | tuple_type
    | LEFT_PARENTHESIS type_ref RIGHT_PARENTHESIS

upper_path_type_ref ::=
    upper_case_qid

type_variable_ref ::=
    LOWER_CASE_IDENTIFIER

record_type ::=
    LEFT_BRACE [[record_base] <<non_empty_list field_type>>] RIGHT_BRACE

field_type ::=
    LOWER_CASE_IDENTIFIER COLON type_ref

tuple_type ::=
    unit
    | LEFT_PARENTHESIS type_ref (COMMA type_ref)+ RIGHT_PARENTHESIS


type_annotation ::= (LOWER_CASE_IDENTIFIER | operator_as_function) COLON type_ref

port_annotation ::= PORT LOWER_CASE_IDENTIFIER COLON type_ref



// EXPRESSIONS


expression ::= list_of_operands (operator list_of_operands)*

list_of_operands ::= [MINUS]operand+

private operator ::=
    OPERATOR
    | LIST_CONSTRUCTOR
    | MINUS
    | DOT

private operand ::=
    literal
    | field_access
    | value_expr
    | field_accessor_function
    | operator_as_function
    | parenthesed_expression
    | tuple_constructor
    | tuple
    | list
    | record
    | if_else
    | case_of
    | let_in
    | anonymous_function
    | glsl_code

parenthesed_expression ::= LEFT_PARENTHESIS expression RIGHT_PARENTHESIS

private literal ::=
    STRING_LITERAL
    | NUMBER_LITERAL
    | CHAR_LITERAL

anonymous_function ::= BACKSLASH pattern+ ARROW expression

external field_accessor_function ::= parseFieldAccessorFunction
external effect ::= parseEffect

external field_access ::= parseFieldAccess
external value_qid ::= parseValueQID
external upper_case_qid ::= parseUpperCaseQID

value_expr ::=
    value_qid
    | upper_case_qid

operator_as_function ::=
    LEFT_PARENTHESIS operator RIGHT_PARENTHESIS

private tuple ::=
    unit
    | non_empty_tuple

non_empty_tuple ::=
    LEFT_PARENTHESIS expression (COMMA expression)+ RIGHT_PARENTHESIS

tuple_constructor ::=
    LEFT_PARENTHESIS COMMA+ RIGHT_PARENTHESIS

unit ::=
    LEFT_PARENTHESIS RIGHT_PARENTHESIS

list ::=
    LEFT_SQUARE_BRACKET [<<non_empty_list expression>>] RIGHT_SQUARE_BRACKET

record ::=
    LEFT_BRACE [[record_base] <<non_empty_list field>>] RIGHT_BRACE

private record_base ::=
    LOWER_CASE_IDENTIFIER PIPE

field ::=
    LOWER_CASE_IDENTIFIER EQ expression

if_else ::=
    IF expression THEN expression ELSE expression


case_of ::=
    CASE expression OF <<non_empty_decls case_of_branch>> VIRTUAL_END_SECTION

case_of_branch ::=
    pattern ARROW expression


let_in ::=
    LET <<non_empty_decls inner_declaration>> VIRTUAL_END_SECTION IN expression

private inner_declaration ::=
    inner_value_declaration
    | inner_type_annotation

inner_value_declaration ::=
    internal_value_declaration_left EQ expression

inner_type_annotation ::=
    LOWER_CASE_IDENTIFIER COLON type_ref



// PATTERNS


pattern ::=
    single_pattern (LIST_CONSTRUCTOR single_pattern)* [pattern_as]

pattern_as ::= AS LOWER_CASE_IDENTIFIER

private single_pattern ::=
    UNDERSCORE
    | lower_pattern
    | union_pattern
    | tuple_pattern
    | unit
    | list_pattern
    | record_pattern
    | literal
    | parenthesed_pattern

lower_pattern ::= LOWER_CASE_IDENTIFIER

record_pattern ::=
    LEFT_BRACE <<non_empty_list lower_pattern>> RIGHT_BRACE

private list_pattern ::=
    LEFT_SQUARE_BRACKET [<<non_empty_list pattern>>] RIGHT_SQUARE_BRACKET

union_pattern ::=
    upper_case_qid pattern*

tuple_pattern ::=
    LEFT_PARENTHESIS pattern (COMMA pattern)+ RIGHT_PARENTHESIS

private parenthesed_pattern ::=
    LEFT_PARENTHESIS pattern RIGHT_PARENTHESIS



// MISC


operator_config ::=
    operator_config_keyword NUMBER_LITERAL operator

private operator_config_keyword ::=
    INFIXL
    | INFIX
    | INFIXR

glsl_code ::= START_GLSL_CODE GLSL_CODE_CONTENT* END_GLSL_CODE;



// UTILITY


private meta non_empty_list ::= <<p>> (COMMA <<p>>)*


// TODO [kl] cleanup the duplication
private meta non_empty_decls ::= <<p>> (VIRTUAL_END_DECL <<p>>)*
private meta decls ::= [VIRTUAL_END_DECL? <<p>> (VIRTUAL_END_DECL <<p>>)*]
